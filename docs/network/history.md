---
sidebar_position: 1
---
# 发展史

## 直连时代（物理层设备）
计算机网络诞生背景就是两台电脑想要通信。那么很简单，连一条网线就行了。   
![](https://img.dingshaohua.com/book-fe/202406271159.jpg)

两台以上电脑想要两两互相通信，如果还是只通过网线连接，那么可能就需要大量的网线！   
![](https://img.dingshaohua.com/book-fe/202406271207.jpg)

## 集线器时代（物理层设备）
如果不想用太多网线，就能实现很多电脑两两互相通信，就有人发明了集线器。

集线器（Hub），就是把线集合起来的机器，可以让每台电脑只需要一根网线就能实现电脑两两通信，集线器解决了网线多的问题（西方很喜欢用hub这个单词，比如Github，Scihub，Pxxnhub，都是一种大型的中心集中式广播消息的系统。）！
![](https://img.dingshaohua.com/book-fe/202406271208.webp)






**🤔集线器是怎么实现电脑通信的问题的呢？**   
它仅仅是通过广播的方式转发到了所有的出口，大家认为集线器基本的无脑转发，所以就将它划分在了物理层。

比如：A想要跟B电脑通信，但是它不知道b在哪，那它就把自己的消息通过网线发送给集线器，集线器再把消息全部广播出去，也就是说其它不相关的电脑也会收到这个消息 需要它们自行过滤掉丢弃，这个就是集线器的原理。
![](https://img.dingshaohua.com/book-fe/202406271213.webp)  

好处是集线器使整个布局干净不少，但原来我只要发给电脑B的消息，现在却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源。如果a只想把消息发送给b的话，集线器就无法满足了，为了解决这个一对一问题，人们就发明了交换机。



## 交换机时代（数据链路层设备）
交换机（Switch），外观和集线器长得没啥差别，都是排了一堆黑色的口子。   
![](https://img.dingshaohua.com/book-fe/202406271210.webp)

**🤔交换机是怎么实现信息两两之间的隐私发送，也就是单播，而不是广播的呢？**    
每台电脑（网卡）生产好以后都有一个独一无二的id，也就是身份证，专业术语叫MAC地址。    
交换机使用这些身份证MAC地址唯一地识别电脑，识别电脑以后就可以唯一地将消息从A发送到B，这就是交换机的意义！


交换机内部维护一张 MAC 地址表，记录着每一个 MAC 地址的设备，连接在其哪一个口上。
|端口|MAC|
|---|---|
|1|aa-aa-aa|
|2|bb-bb-bb|
|...|...|

假如你仍然要发给 B 一个数据包，构造了如下的数据结构从网口出去。 
![](https://img.dingshaohua.com/book-fe/202406271214.jpg)      
到达交换机时，交换机内部通过自己维护的 MAC 地址表，发现目标机器 B 的 MAC 地址 bb-bb-bb-bb-bb-bb 映射到了端口 1 上。
![](https://img.dingshaohua.com/book-fe/202406271218.jpg)   


于是交换机直接把数据通过 1 号端口发给了 B，完事~   

![](https://img.dingshaohua.com/book-fe/202406271216.webp)


使用网络拓扑模拟器来模拟一下，会发现这样也确实 实现了网络互通！  
![](https://img.dingshaohua.com/book-fe/202406271211.webp)

这个通过这样传输方式而组成的小范围的网络，叫做以太网（协议）

:::tip 注意
交换机本身不占用ip，且它的那些网口都不具备MAC地址，它仅仅是通过内部的程序来解析或包装`数据帧`里的ip和data并将其转发到对应下游的终端设备里。
:::

虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做交换机。也正因为这一点点智能，把它归纳到数据链路层。


**🤔交换机内部维护一张 MAC 地址表，是怎么建立起来的呢**   
最开始的时候，MAC 地址表是空的，是怎么逐步建立起来的呢？     
假如在 MAC 地址表为空是，你是 A , 你给 B 发送了如下数据    
![](https://img.dingshaohua.com/book-fe/202406271214.jpg)    

由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC地址表记录第一条数据   
```
MAC：aa-aa-aa-aa-aa-aa-aa
端口：4
```

交换机看目标 MAC 地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了所有端口，也即发给了所有机器。

之后，只有机器 B 收到了确实是发给自己的包，于是做出了响应，响应数据从端口 1 进入交换机，于是交换机此时在地址表中更新了第二条数据
```
MAC：bb-bb-bb-bb-bb-bb
端口：1
```

过程如下   
![](https://img.dingshaohua.com/book-fe/202406271219.webp)

经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕~

随着机器数量越多，交换机的端口也不够了，但聪明的你发现，只要将多个交换机连接起来，这个问题就轻而易举搞定，完全不需要设计额外的东西~   
![](https://img.dingshaohua.com/book-fe/202406271220.jpg)


需要注意，上面那根红色的线，最终在交换机的MAC 地址表中可不是一条记录，而是要把 EFGH 这四台机器与该端口（端口6）的映射全部记录在表中，右边的交换机也是一样会做对应的映射。


| MAC地址 |	端口| 左 VS 右 | MAC地址 |	端口 |
| --- | ---| --- | --- | --- |
| bb-bb-bb-bb-bb-bb | 1 | --- | bb-bb-bb-bb-bb-bb | 1 |
| cc-cc-cc-cc-cc-cc | 3 | --- | cc-cc-cc-cc-cc-cc | 1 |
| aa-aa-aa-aa-aa-aa | 4 | --- | aa-aa-aa-aa-aa-aa | 1 |
| dd-dd-dd-dd-dd-dd | 5 | --- | dd-dd-dd-dd-dd-dd | 1 |
| ee-ee-ee-ee-ee-ee | 6 | --- | ee-ee-ee-ee-ee-ee | 2 |
| ff-ff-ff-ff-ff-ff | 6 | --- | ff-ff-ff-ff-ff-ff | 3 |
| gg-gg-gg-gg-gg-gg | 6 | --- | gg-gg-gg-gg-gg-gg | 4 |
| hh-hh-hh-hh-hh-hh | 6 | --- | hh-hh-hh-hh-hh-hh | 6 |



**🤔问题的暴漏**    
上边提到，将多个交换机连接起来的方式，足以支撑几十台甚至几百台电脑的互联。但电脑的数量很快就发展到了几千、几万、几十万。交换机已经无法记录如此庞大的映射关系了。

此时你发现了问题的根本，就是那根连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来 都是通过这个红线捡来的，才使得地址表越来越大。

## 路由器时代（网络层）
这个时候就发明了路由器这个网络设备了，用它来连接两个交换机了。 
![](https://img.dingshaohua.com/book-fe/202406271212.webp)

路由器有很多个网络接口，每个接口都有一个网络适配器（即网卡）MAC地址。
![](https://img.dingshaohua.com/book-fe/202406271221.webp)

路由器引入了一个ip地址的概念，它给插（接）入它端口的每一个设备都分配一个唯一标识 即ip。   

1. 还是上边的例子，比如A要给C发送数据，经过计算发现C和自己是同一网段，则直接向B发送数据，否则交给路由器去处理

2. 路由器接收A发来的到数据包（内包含数据+目标主机IP）后 解包查看数据包里的目标ip 确定请求目标ip是否和自己同一网段，如果是则结合 自己的路由表，一看发现是192.168.1.xxx 这个子网下的，都转发到 自己1 号网络接口上，进行发送数据（调出arp找到对应目标主机的MAC地址 进行发送数据操作，如果arp缓存没有 就arp广播现找）

3. 如果不是，不同网段互通，必须依靠网关进行处理，于是再找到这台路由器的上层网关（路由器）做同样的操作直至找到目标主机。 比如说A电脑要给百度发送数据，会经历多层网关才能到达。最终的`110.242.68.66`就是百度所在服务器的ip。当然别想通过ip直接访问了，人家在服务器端通过服务器软件（如nginx）就可以禁止     
![](https://img.dingshaohua.com/book-fe/202406280150.jpg)



**🤔 A怎么知道哪个设备是路由器？**  
其实说A 发给路由器不准确，应该说 A 会把包发给默认网关（一般路由器就是网关角色）。  
这个网关是自己在电脑里配置的，默认不配置则一般默认为 `xxx.xxx.1.1` 或者  `xxx.xxx.0.1`。   
网关（路由器）和 终端设备（如 A、B、C）属于同一子网。

**🤔路由器怎么知道哪个设备是C？**   
路由器有个 路由表，里边存储了 局域ip与网络接口的关系。
| 目的地址| 子网掩码| 下一跳| 端口| 
|---|---|---|---|
| 192.168.0.0| 	255.255.255.0| |0| 
| 192.168.0.254| 	255.255.255.255 || 0| 
| 192.168.1.0| 	255.255.255.0 |  |	1 | 
| 192.168.1.254| 255.255.255.255|| 1| 



**🤔什么是同一网段？**        
一般看自己是否属于三类网的某一类，另外再看ip是的前三组是否相等 比如192.168.1.x，最后再看子网掩码是否相同。更精确些其实是有一个计算公式的：设备的ip地址和设备掩码做`&`运算，如果全部匹配则就是属于同一网络也称为同一网段或同一子网。注意的是同属于局域网的设备并不一定是同一子网（由网段和掩码共同决定）。

**🤔A是如何知道自己与B在同一网段内的？**   
A通过自己和B的IP和掩码做运算，就知道是否在同一个三层网段里。同网段就直接通过链路层发送数据包（若没有B的MAC地址 A主机就通过ARP获得）。

**🤔ARP是什么？**      
* ARP是一种用于将IP地址解析为MAC地址的协议。在进行ARP协议时，主机会向本地网络内的所有主机（的网卡）广播一个ARP请求，请求目标主机的MAC地址。目标主机（的网卡）接收到ARP请求后，会向发起ARP请求的主机回复一个包含自己MAC地址的ARP响应。ARP协议的工作原理通过广播的方式在局域网内寻找目标主机的MAC地址，也就是说它的工作范围只在局域网。 
* 主机在以下情况下通常会发送ARP请求：ARP缓存表中没有对应ip的mac地址信息、主机怀疑自己arp过期或损坏了等等。
* ARP欺骗，攻击者只向目标主机发送伪造的ARP响应包，将目标主机的IP地址和MAC地址对应关系改为攻击者的MAC地址。这样，目标主机将网络流量发送到攻击者的MAC地址，攻击者就能够获取到网络流量。



### 谁发起的请求（传输层）
软件里的网络请求，最终都会被转发到tcp和udp请求。 
这些协议的请求都会被操作系统的支持来解释和执行，这个过程开发人员便已经无法干预。 

### 到底是谁发起的？（应用层）
其实是用户，普通人。
他们会使用软件的时候 触发了软件里边有开发人员编写的网络请求 如TTP、FTP、SMTP等。  
这些协议最终被传递到传输层的tcp和udp。




